# 超出頁面文字自動換行（修復紀錄）

## 問題（自然語言）
在 PDF 文字編輯後，如果內容變長，水平文字會一路往右「超出頁面」而不換行；垂直文字則可能往外延伸或被裁切。根本原因不是「沒把框變大」而已，而是渲染時沒有先給足夠的版面空間讓排版引擎決定哪裡該換行，導致超出頁面邊界時只能被截斷。

這次修復的核心做法是：渲染時先給「全頁高度」作為可排版空間，確定文字已經能完整放進頁內後，再用二分法把高度縮回到剛好包住文字的大小；同時在 HTML/CSS 上補上強制斷行規則，讓連續字串（例如沒有空格的長英文、數字串）也能在頁內找到斷點。

## 過程中遇到的錯誤與解法（自然語言）
- 一開始嘗試用 `git apply` 套 patch，但 patch 格式不符合 `git apply` 預期（缺少正確的 diff header / 內容被當成垃圾），因此無法直接套用。
- 後來改用「字串替換」方式修改檔案時，遇到比對 pattern 找不到：原因是原檔案中有一段中文註解在某些輸出/複製過程中變成亂碼，導致用包含該註解的整段文字去比對會失敗。
- 最後做法是避免把中文註解納入匹配條件，改用更穩定的英文/程式碼片段做替換，並在替換完成後再手動修正少量縮排（CSS 區塊縮排跑掉但不影響功能）。

---

## 問題與修復（程式碼語言）

### 1) 症狀與根因
- 症狀：
  - 水平文字：編輯後文字變長，但仍用「接近原框高度」的 `rect` 去 `insert_htmlbox`，結果內容超出頁面邊界不換行/被裁切。
  - 垂直文字：框的計算主要處理 x 向擴張，但如果沒有足夠高度先排版，仍可能裁切或換行不如預期。
- 根因：
  - `insert_htmlbox(rect, ...)` 的排版結果受 `rect` 限制；若初始 `rect` 高度不夠，排版引擎沒有空間把字換到下一行/下一列，只能被截斷。

### 2) 解法 A：先用「全頁高度」排版，再縮回最小高度
在 `model/pdf_model.py` 內做了同一個策略（水平/垂直一致）：
- 先把 `html_rect` 的 `y1` 拉到 `page.rect.y1`，讓排版引擎有足夠高度決定換行。
- 用 `page.get_text(clip=rect)` 做「是否完整渲染」的驗證。
- 用二分法縮減 `y1`，找出「最小仍能完整包含文字」的高度，再加上少量 padding。

對應改動（重點概念）：
```python
# 先用 full-height rect 讓排版能換行
full_rect = fitz.Rect(x0, y0, x1, page.rect.y1)
page.insert_htmlbox(full_rect, html, css=css, rotate=..., scale_low=1)

# 確認文字完整，再二分縮回最小高度
shrink_rect = self._binary_shrink_height(page, full_rect, expected_text, min_y1=base_y1)
```

另外 `_binary_shrink_height` 增加 `min_y1` 參數，避免縮得比原本框更小（避免版面「倒縮」造成看起來變矮）：
```python
def _binary_shrink_height(..., min_y1: float | None = None):
    low = rect.y1 if min_y1 is None else max(rect.y0, min_y1)
    high = page.rect.y1
    ...
```

### 3) 解法 B：CSS 補上強制斷行規則
在 `insert_htmlbox` 的 CSS 中加入：
- `word-break: break-all;`
- `overflow-wrap: anywhere;`

目的：即使遇到「沒有空格、無自然斷點」的長字串，也能在頁內斷行，避免超出頁面。

```css
span {
  white-space: pre-wrap;
  word-break: break-all;
  overflow-wrap: anywhere;
}
```

### 4) 套用位置
主要落點是 `model/pdf_model.py`：
- `_render_text_blocks_from_index`：整頁從索引重繪時套用相同策略。
- `edit_text`：單框重繪時，水平/垂直都先 full-height 排版，再 shrink。

