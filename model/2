    def edit_text(self, page_num: int, rect: fitz.Rect, new_text: str, font: str = "helv", size: int = 12, color: tuple = (0.0, 0.0, 0.0)):
        
        if not new_text.strip():
            logger.warning("文字內容為空，跳過編輯")
            return

        # --- 1. 準備 (Preparation) ---
        is_cjk = any(keyword in font.lower() for keyword in ["han", "serif tc", "cjk", "source", "noto", "微軟", "細明", "標楷", "china", "aptos"])
        if any(0x4e00 <= ord(c) <= 0x9fff for c in new_text):
            is_cjk = True
            logger.debug("偵測到中文，強制 CJK 字體")
        fontname = "china-ts" if is_cjk else "helv"
        logger.debug(f"選擇字體名稱: {fontname} (CJK: {is_cjk}, 輸入: {font}), 傳入顏色: {color}")

        # 估算需要極度寬鬆，以解決問題 H (插入不完整)
        est_width = fitz.get_text_length(new_text, fontname=fontname, fontsize=size) * 3.0 # 300% 寬度緩衝
        lines = new_text.split('\n')
        est_height = len(lines) * size * 1.5 + size # 150% 行高 + 額外一行
        
        # 初始擴展矩形
        expanded_rect = fitz.Rect(rect.x0, rect.y0, rect.x0 + max(rect.width, est_width), rect.y0 + max(rect.height, est_height))

        # --- 8. 清理 (Setup try...finally - 解決 J) ---
        success_snapshot = None
        try:
            # --- 6. 重試迴圈 (Retry Loop - 解決 H 和 I) ---
            max_retries = 3
            success = False
            
            for retry in range(max_retries):
                logger.debug(f"開始編輯重試 {retry+1}/{max_retries}...")
                
                # --- 2. 快照隔離 (Isolation - 解決 J & I) ---
                # 關鍵：每次重試都必須獲取一個 *全新的*、*純淨的* 快照
                temp_doc = self.clone_page(page_num)
                temp_page = temp_doc[0]

                try:
                    # --- 3. 擦除 (Redaction - 解決 I) ---
                    # 立即在快照上擦除舊區域，確保驗證時畫布是乾淨的
                    redact_annot = temp_page.add_redact_annot(rect)
                    temp_page.apply_redactions(images=fitz.PDF_REDACT_IMAGE_NONE)
                    logger.debug(f"重試 {retry+1}: 快照已擦除原始區域 {rect}")

                    # --- 4. 插入 (Insertion - 解決 H) ---
                    rc = temp_page.insert_textbox(
                        expanded_rect, new_text,
                        fontname=fontname,
                        fontsize=size,
                        color=color,
                        align=0,
                        wrap_mode=fitz.TEXT_WRAP_MODE_WHOLEWORD # 防截斷
                    )

                    if isinstance(rc, tuple): spare_height, scale = rc
                    else: spare_height, scale = rc, 1.0

                    # --- 5. 驗證 (Validation - 解決 I) ---
                    if spare_height >= 0 and scale == 1.0:
                        # 驗證 flags，確保讀取我們剛插入的內容
                        inserted_text = temp_page.get_text("text", clip=expanded_rect, flags=fitz.TEXT_INHIBIT_SPACES | fitz.TEXT_DEHYPHENATE).strip()
                        
                        # 規範化處理 (移除所有空白字元再比較)
                        clean_inserted = "".join(inserted_text.split())
                        clean_new = "".join(new_text.strip().split())
                        
                        similarity = difflib.SequenceMatcher(None, clean_inserted, clean_new).ratio()

                        # 使用高相似度 (95%) 和低長度差異 (10%) 作為容忍
                        if similarity > 0.95 or (similarity > 0.8 and abs(len(clean_inserted) - len(clean_new)) < len(clean_new) * 0.1):
                            success = True
                            success_snapshot = temp_doc # 保存這個成功的快照
                            logger.debug(f"驗證成功：相似度 {similarity:.2f} (重試 {retry+1})")
                            break # 成功，跳出重試迴圈
                        else:
                            logger.warning(f"內容不完整：相似度 {similarity:.2f}, 插入: '{inserted_text[:50]}...' != 預期: '{new_text[:50]}...'，繼續重試")
                    else:
                        logger.warning(f"不適合 (spare_height={spare_height}, scale={scale})，擴大 rect")

                    # 如果失敗，關閉當前快照
                    temp_doc.close()
                    
                    # 擴大矩形以進行下一次重試
                    delta_w = 60 * (retry + 1)
                    delta_h = 20 * (retry + 1)
                    expanded_rect = fitz.Rect(
                        expanded_rect.x0, expanded_rect.y0,
                        expanded_rect.x1 + delta_w, expanded_rect.y1 + delta_h
                    )

                except Exception as e:
                    logger.error(f"重試 {retry+1} 內部失敗: {e}")
                    if temp_doc and not temp_doc.is_closed:
                        temp_doc.close() # 確保失敗的快照被關閉
                    raise # 重新拋出內部錯誤
            
            # --- End of Retry Loop ---

            # --- 6. (續) 回退到 TextWriter (如果 insert_textbox 最終失敗) ---
            if not success:
                logger.warning("insert_textbox 全失敗，回退到 TextWriter")
                
                # 同樣需要純淨快照
                temp_doc = self.clone_page(page_num)
                temp_page = temp_doc[0]
                
                # 3. 擦除
                redact_annot_fallback = temp_page.add_redact_annot(rect)
                temp_page.apply_redactions(images=fitz.PDF_REDACT_IMAGE_NONE)
                
                # 4. 插入 (TextWriter)
                shape = temp_page.new_shape()
                # 舊的 TextWriter (shape.insert_textbox) API 可能不穩定，改用 shape.insert_text
                # 我們使用原始矩形的左上角作為插入點
                insert_point = rect.tl
                rc = shape.insert_text(insert_point, new_text, fontname=fontname, fontsize=size, color=color)
                shape.commit()
                logger.debug(f"TextWriter 插入完成 (rc={rc})")

                # 5. 驗證 (TextWriter)
                # 使用 expanded_rect 進行驗證，確保 clip 範圍足夠
                inserted_text = temp_page.get_text("text", clip=expanded_rect, flags=fitz.TEXT_INHIBIT_SPACES | fitz.TEXT_DEHYPHENATE).strip()
                clean_inserted = "".join(inserted_text.split())
                clean_new = "".join(new_text.strip().split())
                similarity = difflib.SequenceMatcher(None, clean_inserted, clean_new).ratio()

                if similarity > 0.95:
                    success = True
                    success_snapshot = temp_doc # 保存成功的 TextWriter 快照
                    logger.debug(f"TextWriter 驗證成功：相似度 {similarity:.2f}")
                else:
                    if temp_doc and not temp_doc.is_closed:
                        temp_doc.close() # 關閉失敗的回退快照
                    raise RuntimeError(f"TextWriter 內容不完整：相似度 {similarity:.2f}")

            # --- 7. 提交 (Commitment) ---
            if success and success_snapshot:
                # 成功！將快照合併回主文件
                self.doc.delete_page(page_num - 1)
                self.doc.insert_pdf(success_snapshot, from_page=0, to_page=0, start_at=page_num - 1)
                page = self.doc.reload_page(page_num - 1) # 必須重新載入頁面引用

                # self.doc.saveIncr() # 根據您的 pdf_model.py，此行為註解
                logger.debug(f"編輯文字成功: 頁面 {page_num}, 文字='{new_text}'")
            else:
                # 邏輯上不應該執行到這裡，但作為防禦
                raise RuntimeError("所有重試和回退均失敗")

        except Exception as insert_e:
            logger.error(f"編輯文字插入失敗，已回滾: {insert_e}")
            raise # 重新拋出錯誤，讓 Controller 捕捉並顯示
        finally:
            # --- 8. 清理 (Cleanup - 解決 J) ---
            # 確保獲勝的快照被關閉
            if success_snapshot and not success_snapshot.is_closed:
                success_snapshot.close()

        # --- 9. 儲存狀態 (State Saving) ---
        self._save_state()
