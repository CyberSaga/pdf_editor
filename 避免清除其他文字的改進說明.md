# 避免清除其他文字方塊的改進說明

## 問題描述

在編輯 PDF 文字時，原本的實現可能會清除掉其他文字方塊內的既有文字，原因是：

1. **矩形定位不精確**：使用粗略的矩形區域進行 Redaction，可能包含多個文字塊
2. **缺乏文字塊檢測**：沒有區分目標文字塊和其他文字塊
3. **插入區域過大**：HTML 插入矩形擴展到整個頁面底部，可能覆蓋其他內容

## 改進方案

### 1. 精確定位目標文字塊

**新增方法：`_find_target_text_block()`**

- 檢測矩形區域內的所有文字塊
- 如果提供了原始文字，使用內容相似度匹配（相似度 > 50%）
- 如果沒有提供原始文字，選擇與矩形中心最接近的文字塊

```python
def _find_target_text_block(self, page_num: int, rect: fitz.Rect, 
                            original_text: str = None) -> dict:
    """精確定位要編輯的目標文字塊"""
    # 1. 獲取矩形內所有文字塊
    text_blocks = self._get_text_blocks_in_rect(page_num, rect)
    
    # 2. 如果提供原始文字，使用內容匹配
    if original_text:
        # 計算相似度，選擇最佳匹配
        ...
    
    # 3. 否則選擇最接近矩形中心的文字塊
    ...
```

### 2. 使用精確的文字邊界

**新增方法：`_get_precise_text_bounds()`**

- 基於實際單詞位置計算精確邊界
- 只清除目標文字塊的實際佔用區域，而非整個矩形

```python
# 改進前：清除整個矩形
temp_page.add_redact_annot(rect)  # 可能包含其他文字

# 改進後：只清除精確的文字邊界
redact_rect = self._get_precise_text_bounds(page_num, target_block)
temp_page.add_redact_annot(redact_rect)  # 只清除目標文字
```

### 3. 插入前衝突檢測

**新增方法：`_check_insertion_conflict()`**

- 檢查插入區域是否會與其他文字塊重疊
- 如果檢測到衝突（重疊 > 10%），自動調整插入位置

```python
# 檢查衝突
conflicts = self._check_insertion_conflict(page_num, html_rect, exclude_block_index)

if conflicts:
    # 調整插入位置，向下移動以避免衝突
    min_y = max(conflict['rect'].y1 for conflict in conflicts)
    html_rect.y0 = min_y + size * 0.5
```

### 4. 優化插入矩形

**改進：不再擴展到頁面底部**

```python
# 改進前：擴展到頁面底部
html_rect = fitz.Rect(rect.x0, rect.y0, rect.x0 + max_allowed_width, page_height)

# 改進後：只擴展到需要的空間
estimated_height = len(new_text.split('\n')) * size * 1.5 + size
html_rect = fitz.Rect(
    redact_rect.x0, 
    redact_rect.y0,
    redact_rect.x0 + max_allowed_width,
    redact_rect.y0 + max(redact_rect.height, estimated_height)
)
```

### 5. 傳遞原始文字以幫助定位

**改進：在編輯時傳遞原始文字內容**

- View 層：儲存點擊位置的原始文字
- Controller 層：將原始文字傳遞給 Model
- Model 層：使用原始文字進行精確匹配

```python
# View 層：儲存原始文字
self.editing_original_text = info[1]  # 從 get_text_info_at_point 獲取

# Controller 層：傳遞原始文字
self.model.edit_text(page, rect, new_text, font, size, color, original_text)

# Model 層：使用原始文字定位
target_block = self._find_target_text_block(page_num, rect, original_text)
```

## 改進效果

### 改進前
- ❌ 可能清除矩形內的所有文字（包括非目標文字）
- ❌ 插入區域過大，可能覆蓋其他內容
- ❌ 無法區分目標文字塊和其他文字塊

### 改進後
- ✅ 只清除目標文字塊的精確區域
- ✅ 插入前檢測衝突，自動調整位置
- ✅ 使用文字內容匹配，精確定位目標
- ✅ 插入區域只擴展到需要的空間

## 使用方式

### 基本使用（自動定位）

```python
# 不需要提供原始文字，系統會自動選擇最接近的文字塊
model.edit_text(page_num, rect, "新文字", "helv", 12, (0, 0, 0))
```

### 精確使用（提供原始文字）

```python
# 提供原始文字可以幫助精確定位
model.edit_text(
    page_num, 
    rect, 
    "新文字", 
    "helv", 
    12, 
    (0, 0, 0),
    original_text="舊文字"  # 幫助精確匹配
)
```

## 技術細節

### 文字塊檢測

使用 `page.get_text("dict")` 獲取結構化的文字資訊：

```python
blocks = page.get_text("dict", flags=0)["blocks"]
for block in blocks:
    if block.get('type') == 0:  # 文字塊
        block_rect = fitz.Rect(block["bbox"])
        # 檢查是否與目標矩形相交
        if block_rect.intersects(rect):
            # 處理文字塊
```

### 相似度匹配

使用 `difflib.SequenceMatcher` 計算文字相似度：

```python
similarity = difflib.SequenceMatcher(
    None, 
    original_text_clean, 
    block_text_clean
).ratio()

if similarity > 0.5:  # 相似度閾值
    # 視為匹配
```

### 衝突檢測

計算重疊比例來判斷是否衝突：

```python
intersection = block_rect & insert_rect
overlap_ratio = (intersection.width * intersection.height) / \
               (block_rect.width * block_rect.height)

if overlap_ratio > 0.1:  # 重疊超過 10%
    # 視為衝突
```

## 注意事項

1. **原始文字參數是可選的**：如果不提供，系統會使用位置匹配
2. **相似度閾值**：目前設定為 50%，可以根據需要調整
3. **衝突檢測閾值**：目前設定為 10% 重疊，可以根據需要調整
4. **性能影響**：文字塊檢測會增加一些計算開銷，但通常可以忽略

## 相關檔案

- `model/pdf_model.py`：主要的改進實現
- `controller/pdf_controller.py`：傳遞原始文字參數
- `view/pdf_view.py`：儲存和傳遞原始文字
- `model/pdf_text_editor_improved.py`：獨立的改進版本（參考用）

## 測試建議

1. **測試場景 1**：編輯一個文字塊，旁邊有其他文字塊
   - 預期：只清除目標文字，其他文字不受影響

2. **測試場景 2**：編輯的文字塊與其他文字塊重疊
   - 預期：自動調整插入位置，避免覆蓋

3. **測試場景 3**：提供原始文字進行編輯
   - 預期：精確匹配目標文字塊

4. **測試場景 4**：不提供原始文字進行編輯
   - 預期：使用位置匹配，選擇最接近的文字塊

---

*最後更新：2024年*
