# 文字方塊索引系統說明

## 概述

為了避免編輯文字時清除其他文字方塊的內容，我們實現了一個**文字方塊索引系統**。這個系統在打開PDF時建立索引，記錄每個文字方塊的內容和位置，編輯時只影響目標文字方塊。

## 核心改進

### 1. 文字方塊索引系統

**在打開PDF時建立索引**

當打開PDF文件時，系統會自動掃描所有頁面，為每個文字方塊建立索引：

```python
def _build_text_block_index(self):
    """建立文字方塊索引，記錄每個文字方塊的內容和位置"""
    # 索引結構：{page_num: [{block_id, rect, text, font, size, color, block_index}, ...]}
    for page_num in range(len(self.doc)):
        # 掃描頁面中的所有文字塊
        # 為每個文字塊分配唯一的 block_id
        # 記錄文字內容、位置、字體等資訊
```

**索引結構**

```python
self.text_block_index = {
    0: [  # 第1頁（0-based）
        {
            'block_id': 'page_0_block_0',
            'rect': fitz.Rect(...),  # 文字方塊邊界
            'text': '這是文字內容',
            'font': 'helv',
            'size': 12.0,
            'color': (0.0, 0.0, 0.0),
            'block_index': 0  # 原始PDF中的塊索引
        },
        ...
    ],
    1: [  # 第2頁
        ...
    ]
}
```

### 2. 精確定位目標文字方塊

**使用索引查找**

編輯時，系統使用索引快速定位目標文字方塊：

```python
def _find_text_block_by_rect(self, page_num, rect, original_text=None):
    """根據矩形和文字內容查找文字方塊（使用索引）"""
    # 1. 在索引中查找與矩形相交的文字方塊
    # 2. 如果提供原始文字，使用內容相似度匹配
    # 3. 否則選擇與矩形中心最接近的文字方塊
```

**優勢**

- ✅ **快速定位**：不需要每次都重新解析整個頁面
- ✅ **精確匹配**：使用 block_id 唯一標識每個文字方塊
- ✅ **內容匹配**：如果提供原始文字，使用相似度匹配提高準確性

### 3. 只清除目標文字方塊

**精確清除**

編輯時，只清除目標文字方塊的精確區域：

```python
# 使用索引中的精確邊界
redact_rect = target_block['rect']  # 只清除這個文字方塊

# 只清除目標區域
temp_page.add_redact_annot(redact_rect)
temp_page.apply_redactions(images=fitz.PDF_REDACT_IMAGE_NONE)
```

**效果**

- ✅ 其他文字方塊完全不受影響
- ✅ 即使文字方塊重疊，也只清除目標方塊
- ✅ 使用精確邊界，避免誤清除

### 4. 允許文字方塊重疊

**不再調整位置**

根據您的要求，系統**不再自動調整插入位置**，允許文字方塊重疊：

```python
# 創建插入矩形（允許重疊）
html_rect = fitz.Rect(
    redact_rect.x0, 
    redact_rect.y0,
    redact_rect.x0 + max_allowed_width,
    redact_rect.y0 + max(redact_rect.height, estimated_height)
)
# 不再檢查衝突，不再調整位置
```

**移除的功能**

- ❌ 移除了 `_check_insertion_conflict()` 的調用
- ❌ 移除了自動位置調整邏輯
- ✅ 允許文字方塊自然重疊

### 5. 索引更新

**編輯後更新索引**

編輯完成後，系統會更新索引中的文字內容：

```python
# 更新索引中的文字內容
if block_id:
    for block in self.text_block_index[page_idx]:
        if block['block_id'] == block_id:
            block['text'] = new_text
            block['font'] = font
            block['size'] = size
            block['color'] = color
```

## 工作流程

### 打開PDF時

1. 複製PDF到臨時目錄
2. 開啟PDF文件
3. **建立文字方塊索引**（新增）
4. 將初始狀態加入撤銷堆疊

### 編輯文字時

1. **使用索引查找目標文字方塊**（改進）
2. 獲取目標文字方塊的精確邊界
3. 在快照上清除目標區域（只清除目標方塊）
4. 插入新文字（允許重疊）
5. 驗證插入結果
6. 應用更改
7. **更新索引**（新增）

## 優勢

### 1. 性能提升

- **索引建立**：只在打開PDF時建立一次
- **快速查找**：編輯時直接使用索引，不需要重新解析
- **減少計算**：不需要每次都檢測所有文字塊

### 2. 精確性提升

- **唯一標識**：每個文字方塊有唯一的 block_id
- **內容匹配**：使用原始文字進行相似度匹配
- **精確邊界**：使用索引中記錄的精確邊界

### 3. 安全性提升

- **只影響目標**：只清除和重繪目標文字方塊
- **其他方塊保護**：其他文字方塊完全不受影響
- **允許重疊**：不強制調整位置，尊重用戶意圖

## 使用方式

### 基本使用

索引系統是**自動的**，不需要額外操作：

```python
# 打開PDF時自動建立索引
model.open_pdf("document.pdf")

# 編輯文字時自動使用索引
model.edit_text(page_num, rect, "新文字", "helv", 12, (0, 0, 0))
```

### 提供原始文字（可選）

提供原始文字可以幫助精確匹配：

```python
model.edit_text(
    page_num, 
    rect, 
    "新文字", 
    "helv", 
    12, 
    (0, 0, 0),
    original_text="舊文字"  # 幫助精確匹配
)
```

## 技術細節

### 索引建立時機

- **打開PDF時**：`open_pdf()` 方法中自動建立
- **關閉PDF時**：`close()` 方法中清除索引
- **重新打開時**：清除舊索引，建立新索引

### 索引更新時機

- **編輯文字後**：更新目標文字方塊的內容
- **不更新位置**：rect 保持不變（除非需要）

### 回退機制

如果索引中找不到匹配的文字方塊，系統會回退到動態檢測：

```python
if not candidates:
    # 回退到動態檢測
    return self._find_target_text_block(page_num, rect, original_text)
```

## 注意事項

1. **索引建立時間**：大型PDF可能需要一些時間建立索引
2. **記憶體使用**：索引會佔用一些記憶體，但通常可以忽略
3. **索引同步**：編輯後會更新索引，但位置（rect）不會自動更新
4. **重疊處理**：允許文字方塊重疊，不會自動調整位置

## 相關檔案

- `model/pdf_model.py`：主要的實現
  - `_build_text_block_index()`：建立索引
  - `_find_text_block_by_rect()`：使用索引查找
  - `edit_text()`：使用索引進行編輯

## 未來改進方向

1. **索引持久化**：可以將索引儲存到檔案，避免每次打開都重新建立
2. **增量更新**：只更新變更的文字方塊，而不是重新建立整個索引
3. **位置更新**：編輯後自動更新 rect（如果需要）
4. **索引壓縮**：對於大型PDF，可以壓縮索引以節省記憶體

---

*最後更新：2024年*
